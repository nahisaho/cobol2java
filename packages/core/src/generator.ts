/**
 * Java Code Generator
 * 
 * Generates Java source code from COBOL AST
 */

import { type CobolAst, type DataItem, type Paragraph, type FileDefinition } from './parser.js';
import { type LLMClient } from './llm/index.js';
import { type ErrorInfo } from './errors.js';
import { mapDataType, toJavaName, toClassName, transformStatement } from './transform/index.js';

/**
 * Generator options
 */
export interface GeneratorOptions {
  /** Target Java package name */
  packageName: string;
  /** Target Java version */
  javaVersion: 11 | 17 | 21;
  /** Generate Spring Boot compatible code */
  springBoot: boolean;
  /** Generate Spring Batch compatible code (tasklet/job) */
  springBatch: boolean;
  /** Generate data validation helpers */
  generateValidation?: boolean;
  /** LLM client for advanced transformations */
  llmClient?: LLMClient;
}

/**
 * Generated code result
 */
export interface GeneratedCode {
  /** Generated Java source code */
  code: string;
  /** Generated class name */
  className: string;
  /** Warnings during generation */
  warnings: ErrorInfo[];
  /** Spring Batch job configuration (if springBatch is true) */
  batchConfig?: string;
  /** Validation helper class (if generateValidation is true) */
  validationHelper?: string;
}

/**
 * Java Code Generator
 */
export class JavaGenerator {
  private readonly options: GeneratorOptions;

  constructor(options: GeneratorOptions) {
    this.options = options;
  }

  /**
   * Generate Java code from COBOL AST
   */
  async generate(ast: CobolAst): Promise<GeneratedCode> {
    const warnings: ErrorInfo[] = [];
    
    // Convert COBOL program name to Java class name
    const className = toClassName(ast.programName || 'Program');
    
    // Generate Java code
    const code = this.generateClass(ast, className);

    // Generate Spring Batch configuration if springBatch is enabled
    const batchConfig = this.options.springBatch 
      ? this.generateBatchConfig(className)
      : undefined;

    // Generate validation helper if generateValidation is enabled
    const validationHelper = this.options.generateValidation
      ? this.generateValidationHelper(ast.dataItems, className)
      : undefined;

    return {
      code,
      className,
      warnings,
      batchConfig,
      validationHelper,
    };
  }

  /**
   * Generate Java class structure
   */
  private generateClass(ast: CobolAst, className: string): string {
    const lines: string[] = [];

    // Package declaration
    lines.push(`package ${this.options.packageName};`);
    lines.push('');

    // Imports
    const imports = this.generateImports(ast);
    if (imports.length > 0) {
      lines.push(...imports);
      lines.push('');
    }

    // Class comment
    lines.push('/**');
    lines.push(` * Converted from COBOL program: ${ast.programName || 'Unknown'}`);
    lines.push(' * Generated by cobol2java');
    if (this.options.springBatch) {
      lines.push(' * ');
      lines.push(' * Spring Batch Tasklet - Executes as a step in a batch job');
    } else if (this.options.springBoot) {
      lines.push(' * ');
      lines.push(' * Spring Boot Service - Can be injected into other components');
    }
    lines.push(' */');

    // Class annotations (Spring Batch)
    if (this.options.springBatch) {
      lines.push('@Slf4j');
      lines.push('@Component');
    } else if (this.options.springBoot) {
      lines.push('@Slf4j');
      lines.push('@Service');
    }

    // Class declaration
    if (this.options.springBatch) {
      lines.push(`public class ${className} implements Tasklet {`);
    } else {
      lines.push(`public class ${className} {`);
    }
    lines.push('');

    // Generate file handler fields from FILE-CONTROL
    const fileFields = this.generateFileFields(ast.fileDefinitions || []);
    if (fileFields.length > 0) {
      lines.push('    // File handlers (from ENVIRONMENT DIVISION FILE-CONTROL)');
      lines.push(...fileFields);
      lines.push('');
    }

    // Generate fields from DATA DIVISION
    const fields = this.generateFields(ast.dataItems);
    if (fields.length > 0) {
      lines.push('    // Working storage fields');
      lines.push(...fields);
      lines.push('');
    }

    // Generate main execute method
    if (this.options.springBatch) {
      lines.push('    /**');
      lines.push('     * Tasklet execute method (converted from PROCEDURE DIVISION)');
      lines.push('     * @param contribution the step contribution');
      lines.push('     * @param chunkContext the chunk context');
      lines.push('     * @return RepeatStatus.FINISHED when complete');
      lines.push('     */');
      lines.push('    @Override');
      lines.push('    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {');
      lines.push('        log.info("Starting batch tasklet: {}");');
    } else {
      lines.push('    /**');
      lines.push('     * Main entry point (converted from PROCEDURE DIVISION)');
      lines.push('     */');
      lines.push('    public void execute() {');
    }
    
    // Find the main paragraph (first one) and generate its code
    if (ast.paragraphs.length > 0) {
      const mainPara = ast.paragraphs[0];
      if (mainPara) {
        lines.push(`        // ${mainPara.name}`);
        const statements = this.generateStatements(mainPara.statements, 2);
        lines.push(...statements);
      }
    } else {
      lines.push('        // TODO: Implement converted logic');
    }

    if (this.options.springBatch) {
      lines.push('');
      lines.push('        log.info("Batch tasklet completed successfully");');
      lines.push('        return RepeatStatus.FINISHED;');
    }
    
    lines.push('    }');
    lines.push('');

    // Generate methods from paragraphs (skip first/main)
    for (let i = 1; i < ast.paragraphs.length; i++) {
      const para = ast.paragraphs[i];
      if (para) {
        const methodLines = this.generateMethod(para);
        lines.push(...methodLines);
        lines.push('');
      }
    }

    // Main method for standalone execution
    if (!this.options.springBoot && !this.options.springBatch) {
      lines.push('    /**');
      lines.push('     * Standalone entry point');
      lines.push('     */');
      lines.push('    public static void main(String[] args) {');
      lines.push(`        ${className} program = new ${className}();`);
      lines.push('        program.execute();');
      lines.push('    }');
    }

    lines.push('}');
    lines.push(''); // Final newline

    return lines.join('\n');
  }

  /**
   * Generate import statements
   */
  private generateImports(ast: CobolAst): string[] {
    const imports: string[] = [];
    
    if (this.options.springBatch) {
      imports.push('import lombok.extern.slf4j.Slf4j;');
      imports.push('import org.springframework.batch.core.StepContribution;');
      imports.push('import org.springframework.batch.core.scope.context.ChunkContext;');
      imports.push('import org.springframework.batch.core.step.tasklet.Tasklet;');
      imports.push('import org.springframework.batch.repeat.RepeatStatus;');
      imports.push('import org.springframework.stereotype.Component;');
    } else if (this.options.springBoot) {
      imports.push('import lombok.extern.slf4j.Slf4j;');
      imports.push('import org.springframework.stereotype.Service;');
    }

    // Check if BigDecimal is needed
    const needsBigDecimal = ast.dataItems.some(item => {
      if (!item.pic) return false;
      const javaType = mapDataType(item.pic);
      return javaType === 'BigDecimal';
    });

    if (needsBigDecimal) {
      imports.push('import java.math.BigDecimal;');
    }

    // Check if file I/O is needed
    const hasFileDefinitions = (ast.fileDefinitions?.length ?? 0) > 0;
    if (hasFileDefinitions) {
      imports.push('import java.io.*;');
      imports.push('import java.nio.file.*;');
    }

    return imports;
  }

  /**
   * Generate file handler fields from file definitions
   */
  private generateFileFields(fileDefinitions: FileDefinition[]): string[] {
    const lines: string[] = [];

    for (const fileDef of fileDefinitions) {
      const javaName = toJavaName(fileDef.selectName);
      const pathVar = `${javaName}Path`;
      const readerVar = `${javaName}Reader`;
      const writerVar = `${javaName}Writer`;
      const statusVar = fileDef.fileStatus ? toJavaName(fileDef.fileStatus) : `${javaName}Status`;

      // File path
      lines.push(`    // File: ${fileDef.selectName} (${fileDef.organization || 'SEQUENTIAL'})`);
      if (fileDef.assignTo) {
        lines.push(`    private String ${pathVar} = "${fileDef.assignTo}";`);
      } else {
        lines.push(`    private String ${pathVar};`);
      }

      // Reader/Writer based on organization
      if (fileDef.organization === 'INDEXED') {
        // Indexed files need a Map-based approach
        const keyType = fileDef.recordKey ? 'String' : 'String';
        lines.push(`    private java.util.Map<${keyType}, String> ${javaName}Data = new java.util.LinkedHashMap<>();`);
      }
      
      lines.push(`    private BufferedReader ${readerVar};`);
      lines.push(`    private BufferedWriter ${writerVar};`);
      lines.push(`    private String ${statusVar} = "00";  // File status`);
      lines.push('');
    }

    return lines;
  }

  /**
   * Generate field declarations from data items
   */
  private generateFields(dataItems: DataItem[]): string[] {
    const lines: string[] = [];

    for (const item of dataItems) {
      if (item.level === 1 || item.level === 77) {
        // Skip group items or generate as comment
        if (!item.pic) {
          lines.push(`    // Group: ${item.name}`);
          continue;
        }
      }

      const javaType = item.pic ? mapDataType(item.pic) : 'Object';
      const javaName = toJavaName(item.name);
      
      // Handle REDEFINES - generate view/accessor method
      if (item.redefines) {
        const redefinesName = toJavaName(item.redefines);
        lines.push(`    // REDEFINES ${item.redefines}`);
        if (item.pic) {
          lines.push(`    private ${javaType} get${this.capitalize(javaName)}() {`);
          lines.push(`        return (${javaType}) reinterpret(${redefinesName}, ${javaType}.class);`);
          lines.push(`    }`);
          lines.push(`    private void set${this.capitalize(javaName)}(${javaType} value) {`);
          lines.push(`        ${redefinesName} = reinterpretBack(value, ${redefinesName}.getClass());`);
          lines.push(`    }`);
        } else {
          // Group REDEFINES - just add comment
          lines.push(`    // ${javaName} shares storage with ${redefinesName}`);
        }
        continue;
      }
      
      let declaration = `    private ${javaType} ${javaName}`;
      
      if (item.value !== undefined) {
        const initValue = this.formatValue(item.value, javaType);
        declaration += ` = ${initValue}`;
      } else {
        declaration += ` = ${this.getDefaultValue(javaType)}`;
      }
      
      declaration += `;`;
      
      if (item.occurs) {
        // Convert to array
        declaration = `    private ${javaType}[] ${javaName} = new ${javaType}[${item.occurs}];`;
      }
      
      lines.push(declaration);
    }

    return lines;
  }

  /**
   * Format a value for Java
   */
  private formatValue(value: string, javaType: string): string {
    switch (javaType) {
      case 'String':
        return `"${value}"`;
      case 'int':
      case 'long':
        return value.replace(/[^\d-]/g, '') || '0';
      case 'float':
        return `${value}f`;
      case 'double':
        return value;
      case 'BigDecimal':
        return `new BigDecimal("${value}")`;
      default:
        return `"${value}"`;
    }
  }

  /**
   * Get default value for a Java type
   */
  private getDefaultValue(javaType: string): string {
    switch (javaType) {
      case 'String': return '""';
      case 'int': return '0';
      case 'long': return '0L';
      case 'float': return '0.0f';
      case 'double': return '0.0';
      case 'BigDecimal': return 'BigDecimal.ZERO';
      case 'boolean': return 'false';
      default: return 'null';
    }
  }

  /**
   * Generate statements from COBOL statements with proper indentation
   */
  private generateStatements(statements: string[], baseIndent: number = 0): string[] {
    const lines: string[] = [];
    let currentIndent = baseIndent;
    let inSwitch = false;
    let inCase = false;

    for (const stmt of statements) {
      const transformed = transformStatement(stmt);
      if (transformed) {
        // Check if this closes a block (decreases indent before adding)
        if (transformed === '}') {
          // If we were in a case, add break before closing switch
          if (inCase) {
            const breakIndent = '    '.repeat(currentIndent);
            lines.push(`${breakIndent}break;`);
            inCase = false;
          }
          if (inSwitch) {
            inSwitch = false;
          }
          currentIndent = Math.max(0, currentIndent - 1);
        }
        
        // Handle case statements - add break before next case if needed
        if (transformed.startsWith('case ') || transformed === 'default:') {
          // Add break to previous case if we were in one
          if (inCase) {
            const breakIndent = '    '.repeat(currentIndent);
            lines.push(`${breakIndent}break;`);
          }
          inCase = true;
        }
        
        const indent = '    '.repeat(currentIndent);
        lines.push(`${indent}${transformed}`);
        
        // Check if this opens a block (increases indent after adding)
        if (transformed.endsWith('{')) {
          currentIndent++;
          if (transformed.startsWith('switch')) {
            inSwitch = true;
          }
        }
        
        // Increase indent after case/default for the body
        if (transformed.startsWith('case ') || transformed === 'default:') {
          currentIndent++;
        }
        
        // Statement inside case - decrease indent after
        if (inCase && !transformed.startsWith('case') && transformed !== 'default:' && !transformed.endsWith('{') && transformed !== '}') {
          currentIndent = Math.max(0, currentIndent - 1);
        }
      } else {
        // Add as comment if not transformable
        const indent = '    '.repeat(currentIndent);
        lines.push(`${indent}// TODO: ${stmt}`);
      }
    }

    return lines;
  }

  /**
   * Generate a method from a paragraph
   */
  private generateMethod(para: Paragraph): string[] {
    const lines: string[] = [];
    const methodName = toJavaName(para.name);

    lines.push('    /**');
    lines.push(`     * Converted from paragraph: ${para.name}`);
    lines.push('     */');
    lines.push(`    private void ${methodName}() {`);

    const statements = this.generateStatements(para.statements, 2);
    if (statements.length > 0) {
      lines.push(...statements);
    } else {
      lines.push('        // No statements');
    }

    lines.push('    }');

    return lines;
  }

  /**
   * Capitalize first letter
   */
  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  /**
   * Generate Spring Batch job configuration
   */
  private generateBatchConfig(className: string): string {
    const jobName = this.camelToKebab(className);
    const taskletBeanName = this.lowercaseFirst(className);
    
    const lines: string[] = [];
    
    lines.push(`package ${this.options.packageName}.config;`);
    lines.push('');
    lines.push('import lombok.RequiredArgsConstructor;');
    lines.push('import org.springframework.batch.core.Job;');
    lines.push('import org.springframework.batch.core.Step;');
    lines.push('import org.springframework.batch.core.job.builder.JobBuilder;');
    lines.push('import org.springframework.batch.core.repository.JobRepository;');
    lines.push('import org.springframework.batch.core.step.builder.StepBuilder;');
    lines.push('import org.springframework.context.annotation.Bean;');
    lines.push('import org.springframework.context.annotation.Configuration;');
    lines.push('import org.springframework.transaction.PlatformTransactionManager;');
    lines.push(`import ${this.options.packageName}.${className};`);
    lines.push('');
    lines.push('/**');
    lines.push(` * Spring Batch configuration for ${className}`);
    lines.push(' * Generated by cobol2java');
    lines.push(' */');
    lines.push('@Configuration');
    lines.push('@RequiredArgsConstructor');
    lines.push(`public class ${className}BatchConfig {`);
    lines.push('');
    lines.push('    private final JobRepository jobRepository;');
    lines.push('    private final PlatformTransactionManager transactionManager;');
    lines.push(`    private final ${className} ${taskletBeanName};`);
    lines.push('');
    lines.push('    @Bean');
    lines.push(`    public Job ${taskletBeanName}Job() {`);
    lines.push(`        return new JobBuilder("${jobName}-job", jobRepository)`);
    lines.push(`            .start(${taskletBeanName}Step())`);
    lines.push('            .build();');
    lines.push('    }');
    lines.push('');
    lines.push('    @Bean');
    lines.push(`    public Step ${taskletBeanName}Step() {`);
    lines.push(`        return new StepBuilder("${jobName}-step", jobRepository)`);
    lines.push(`            .tasklet(${taskletBeanName}, transactionManager)`);
    lines.push('            .build();');
    lines.push('    }');
    lines.push('}');
    lines.push('');
    
    return lines.join('\n');
  }

  /**
   * Generate validation helper class based on data items' PIC clauses
   */
  private generateValidationHelper(dataItems: DataItem[], className: string): string {
    const lines: string[] = [];
    const validatorClassName = `${className}Validator`;

    lines.push(`package ${this.options.packageName};`);
    lines.push('');
    lines.push('import java.util.ArrayList;');
    lines.push('import java.util.List;');
    lines.push('import java.util.regex.Pattern;');
    lines.push('');
    lines.push('/**');
    lines.push(` * Validation helper for ${className}`);
    lines.push(' * Generated from COBOL PIC clause definitions');
    lines.push(' */');
    lines.push(`public class ${validatorClassName} {`);
    lines.push('');
    lines.push('    private final List<String> errors = new ArrayList<>();');
    lines.push('');

    // Generate validation methods for each data item
    for (const item of dataItems) {
      if (item.pic && item.level !== 88) {
        const methodLines = this.generateValidationMethod(item);
        lines.push(...methodLines);
      }
    }

    // Generate validateAll method
    lines.push('    /**');
    lines.push('     * Validate all fields and return errors');
    lines.push('     */');
    lines.push(`    public List<String> validateAll(${className} data) {`);
    lines.push('        errors.clear();');
    for (const item of dataItems) {
      if (item.pic && item.level !== 88) {
        const fieldName = toJavaName(item.name);
        lines.push(`        validate${this.capitalize(fieldName)}(data.${fieldName});`);
      }
    }
    lines.push('        return new ArrayList<>(errors);');
    lines.push('    }');
    lines.push('');

    // Generate helper methods
    lines.push('    private void addError(String field, String message) {');
    lines.push('        errors.add(field + ": " + message);');
    lines.push('    }');
    lines.push('');

    lines.push('    /**');
    lines.push('     * Check if validation passed');
    lines.push('     */');
    lines.push('    public boolean isValid() {');
    lines.push('        return errors.isEmpty();');
    lines.push('    }');
    lines.push('}');
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Generate validation method for a single data item based on PIC clause
   */
  private generateValidationMethod(item: DataItem): string[] {
    const lines: string[] = [];
    const fieldName = toJavaName(item.name);
    const methodName = `validate${this.capitalize(fieldName)}`;
    const javaType = mapDataType(item.pic!);
    
    lines.push('    /**');
    lines.push(`     * Validate ${fieldName} based on PIC ${item.pic}`);
    lines.push('     */');
    lines.push(`    public boolean ${methodName}(${javaType} value) {`);

    const pic = item.pic!.toUpperCase();
    
    // Parse PIC clause for validation
    if (pic.includes('X') || pic.includes('A')) {
      // String type validation
      const length = this.extractPicLength(pic);
      if (length > 0) {
        lines.push(`        if (value != null && value.length() > ${length}) {`);
        lines.push(`            addError("${fieldName}", "Maximum length is ${length}");`);
        lines.push('            return false;');
        lines.push('        }');
      }
      if (pic.includes('A')) {
        lines.push('        if (value != null && !value.matches("^[a-zA-Z ]*$")) {');
        lines.push(`            addError("${fieldName}", "Must contain only alphabetic characters");`);
        lines.push('            return false;');
        lines.push('        }');
      }
    } else if (pic.includes('9') || pic.includes('S')) {
      // Numeric validation
      const length = this.extractPicLength(pic.replace(/[SV\-.]/g, ''));
      const isSigned = pic.includes('S');
      const hasDecimal = pic.includes('V') || pic.includes('.');
      
      if (!hasDecimal && javaType === 'int') {
        const maxVal = Math.pow(10, length) - 1;
        const minVal = isSigned ? -maxVal : 0;
        lines.push(`        if (value < ${minVal} || value > ${maxVal}) {`);
        lines.push(`            addError("${fieldName}", "Value must be between ${minVal} and ${maxVal}");`);
        lines.push('            return false;');
        lines.push('        }');
      }
    }

    lines.push('        return true;');
    lines.push('    }');
    lines.push('');

    return lines;
  }

  /**
   * Extract length from PIC clause
   */
  private extractPicLength(pic: string): number {
    // Handle PIC X(10) or PIC 9(5)
    const matchParen = pic.match(/[X9A]\((\d+)\)/i);
    if (matchParen) {
      return parseInt(matchParen[1]!, 10);
    }
    // Handle PIC XXXXX or PIC 99999
    const matchRepeat = pic.match(/([X9A]+)/i);
    if (matchRepeat) {
      return matchRepeat[1]!.length;
    }
    return 0;
  }

  /**
   * Convert camelCase to kebab-case
   */
  private camelToKebab(str: string): string {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
  }

  /**
   * Lowercase first letter
   */
  private lowercaseFirst(str: string): string {
    return str.charAt(0).toLowerCase() + str.slice(1);
  }
}
