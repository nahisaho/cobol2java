/**
 * Java Code Generator
 * 
 * Generates Java source code from COBOL AST
 */

import { type CobolAst, type DataItem, type Paragraph } from './parser.js';
import { type LLMClient } from './llm/index.js';
import { type ErrorInfo } from './errors.js';
import { mapDataType, toJavaName, toClassName, transformStatement } from './transform/index.js';

/**
 * Generator options
 */
export interface GeneratorOptions {
  /** Target Java package name */
  packageName: string;
  /** Target Java version */
  javaVersion: 11 | 17 | 21;
  /** Generate Spring Boot compatible code */
  springBoot: boolean;
  /** LLM client for advanced transformations */
  llmClient?: LLMClient;
}

/**
 * Generated code result
 */
export interface GeneratedCode {
  /** Generated Java source code */
  code: string;
  /** Generated class name */
  className: string;
  /** Warnings during generation */
  warnings: ErrorInfo[];
}

/**
 * Java Code Generator
 */
export class JavaGenerator {
  private readonly options: GeneratorOptions;

  constructor(options: GeneratorOptions) {
    this.options = options;
  }

  /**
   * Generate Java code from COBOL AST
   */
  async generate(ast: CobolAst): Promise<GeneratedCode> {
    const warnings: ErrorInfo[] = [];
    
    // Convert COBOL program name to Java class name
    const className = toClassName(ast.programName || 'Program');
    
    // Generate Java code
    const code = this.generateClass(ast, className);

    return {
      code,
      className,
      warnings,
    };
  }

  /**
   * Generate Java class structure
   */
  private generateClass(ast: CobolAst, className: string): string {
    const lines: string[] = [];

    // Package declaration
    lines.push(`package ${this.options.packageName};`);
    lines.push('');

    // Imports
    const imports = this.generateImports(ast);
    if (imports.length > 0) {
      lines.push(...imports);
      lines.push('');
    }

    // Class comment
    lines.push('/**');
    lines.push(` * Converted from COBOL program: ${ast.programName || 'Unknown'}`);
    lines.push(' * Generated by cobol2java');
    lines.push(' */');

    // Class annotation (Spring Boot)
    if (this.options.springBoot) {
      lines.push('@Service');
    }

    // Class declaration
    lines.push(`public class ${className} {`);
    lines.push('');

    // Generate fields from DATA DIVISION
    const fields = this.generateFields(ast.dataItems);
    if (fields.length > 0) {
      lines.push('    // Working storage fields');
      lines.push(...fields);
      lines.push('');
    }

    // Generate main execute method
    lines.push('    /**');
    lines.push('     * Main entry point (converted from PROCEDURE DIVISION)');
    lines.push('     */');
    lines.push('    public void execute() {');
    
    // Find the main paragraph (first one) and generate its code
    if (ast.paragraphs.length > 0) {
      const mainPara = ast.paragraphs[0];
      if (mainPara) {
        lines.push(`        // ${mainPara.name}`);
        const statements = this.generateStatements(mainPara.statements, 2);
        lines.push(...statements);
      }
    } else {
      lines.push('        // TODO: Implement converted logic');
    }
    
    lines.push('    }');
    lines.push('');

    // Generate methods from paragraphs (skip first/main)
    for (let i = 1; i < ast.paragraphs.length; i++) {
      const para = ast.paragraphs[i];
      if (para) {
        const methodLines = this.generateMethod(para);
        lines.push(...methodLines);
        lines.push('');
      }
    }

    // Main method for standalone execution
    if (!this.options.springBoot) {
      lines.push('    /**');
      lines.push('     * Standalone entry point');
      lines.push('     */');
      lines.push('    public static void main(String[] args) {');
      lines.push(`        ${className} program = new ${className}();`);
      lines.push('        program.execute();');
      lines.push('    }');
    }

    lines.push('}');
    lines.push(''); // Final newline

    return lines.join('\n');
  }

  /**
   * Generate import statements
   */
  private generateImports(ast: CobolAst): string[] {
    const imports: string[] = [];
    
    if (this.options.springBoot) {
      imports.push('import org.springframework.stereotype.Service;');
    }

    // Check if BigDecimal is needed
    const needsBigDecimal = ast.dataItems.some(item => {
      if (!item.pic) return false;
      const javaType = mapDataType(item.pic);
      return javaType === 'BigDecimal';
    });

    if (needsBigDecimal) {
      imports.push('import java.math.BigDecimal;');
    }

    return imports;
  }

  /**
   * Generate field declarations from data items
   */
  private generateFields(dataItems: DataItem[]): string[] {
    const lines: string[] = [];

    for (const item of dataItems) {
      if (item.level === 1 || item.level === 77) {
        // Skip group items or generate as comment
        if (!item.pic) {
          lines.push(`    // Group: ${item.name}`);
          continue;
        }
      }

      const javaType = item.pic ? mapDataType(item.pic) : 'Object';
      const javaName = toJavaName(item.name);
      
      let declaration = `    private ${javaType} ${javaName}`;
      
      if (item.value !== undefined) {
        const initValue = this.formatValue(item.value, javaType);
        declaration += ` = ${initValue}`;
      } else {
        declaration += ` = ${this.getDefaultValue(javaType)}`;
      }
      
      declaration += `;`;
      
      if (item.occurs) {
        // Convert to array
        declaration = `    private ${javaType}[] ${javaName} = new ${javaType}[${item.occurs}];`;
      }
      
      lines.push(declaration);
    }

    return lines;
  }

  /**
   * Format a value for Java
   */
  private formatValue(value: string, javaType: string): string {
    switch (javaType) {
      case 'String':
        return `"${value}"`;
      case 'int':
      case 'long':
        return value.replace(/[^\d-]/g, '') || '0';
      case 'float':
        return `${value}f`;
      case 'double':
        return value;
      case 'BigDecimal':
        return `new BigDecimal("${value}")`;
      default:
        return `"${value}"`;
    }
  }

  /**
   * Get default value for a Java type
   */
  private getDefaultValue(javaType: string): string {
    switch (javaType) {
      case 'String': return '""';
      case 'int': return '0';
      case 'long': return '0L';
      case 'float': return '0.0f';
      case 'double': return '0.0';
      case 'BigDecimal': return 'BigDecimal.ZERO';
      case 'boolean': return 'false';
      default: return 'null';
    }
  }

  /**
   * Generate statements from COBOL statements with proper indentation
   */
  private generateStatements(statements: string[], baseIndent: number = 0): string[] {
    const lines: string[] = [];
    let currentIndent = baseIndent;

    for (const stmt of statements) {
      const transformed = transformStatement(stmt);
      if (transformed) {
        // Check if this closes a block (decreases indent before adding)
        if (transformed === '}') {
          currentIndent = Math.max(0, currentIndent - 1);
        }
        
        const indent = '    '.repeat(currentIndent);
        lines.push(`${indent}${transformed}`);
        
        // Check if this opens a block (increases indent after adding)
        if (transformed.endsWith('{')) {
          currentIndent++;
        }
      } else {
        // Add as comment if not transformable
        const indent = '    '.repeat(currentIndent);
        lines.push(`${indent}// TODO: ${stmt}`);
      }
    }

    return lines;
  }

  /**
   * Generate a method from a paragraph
   */
  private generateMethod(para: Paragraph): string[] {
    const lines: string[] = [];
    const methodName = toJavaName(para.name);

    lines.push('    /**');
    lines.push(`     * Converted from paragraph: ${para.name}`);
    lines.push('     */');
    lines.push(`    private void ${methodName}() {`);

    const statements = this.generateStatements(para.statements, 2);
    if (statements.length > 0) {
      lines.push(...statements);
    } else {
      lines.push('        // No statements');
    }

    lines.push('    }');

    return lines;
  }
}
